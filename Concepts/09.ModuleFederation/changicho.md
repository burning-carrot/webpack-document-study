# Module Federation

`하나의 큰 애플리케이션을 여러개의 독립된 애플리케이션으로 만든 다음, 다이나믹 로딩을 하듯이 필요한 순간에 필요한 컴포넌트 (소스)를 불러오게 한다.`

모듈 연합체

분리된 각각의 컴포넌트, 서비스 단위로 따로 개발하여 적용할 수 있지만 수정사항을 반영하려면 앱을 다시 빌드하고 배포하는 과정이 필요하다.

Module Federation을 사용할 경우 각각의 컴포넌트, 서비스 단위가 각각의 빌드를 구성하고 그 빌드를 동적으로 최상단 Host 앱에서 불러와 사용한다.

## Motivation

여러 개의 개별 빌드가 단일 애플리케이션을 형성해야 한다.

이러한 개별 빌드는 서로 의존성이 없어서, 개별적으로 개발하고 배포할 수 있다.

Micro-Frontends 라고 알려져있으나, 이것만 의미하지는 않는다.

## Low-level concepts

Module federation을 사용하면 로컬 모듈과 원격 모듈을 구분한다.

- 로컬 모듈 : 현재 빌드의 일부인 일반 모듈
- 원격 모듈 : 현재 빌드의 일부가 아님. 런타임중에 container에서 로드되는 모듈

원격 모듈을 로드 하는 것은 비동기 작업이다.

원격 모듈을 사용할 때 이런 비동기 작업은, 원격 모듈과 엔트리 포인트 사이에 있는 다음 청크 로드 작업에 배치된다.

청크 로드 작업은 일반적으로 `import()`를 호출하는 것이지만, `require.ensure` 또는 `require([...])` 같은 이전 구조도 지원한다.

원격 모듈을 로드하기 위한 접근을 제공하는 container의 entry를 통해서 container가 생성된다.

접근은 두 단계로 볼 수 있다.

1. 모듈 로드(비동기) : 청크 로드 중 수행
2. 모듈 평가(비동기) : 다른 로컬 및 원격 모듈과 합쳐진 모듈 평가 중 수행

(합쳐진 모듈 평가 중에 수행하면 모듈을 원격으로, 또는 그 반대로 변환해도 순서가 영향을 받지 않음)

container 끼리는 다음과 같은 특징을 가진다.

- container를 중첩할 수 있다.
- container는 다른 container의 모듈을 사용할 수 있다.
- container 간의 순환 의존성도 가능하다.

## High-level concepts

각각의 빌드는 컨테이너의 역할을 하며 다른 빌드를 컨테이너로 소비하기도 한다.

이렇게 각각의 빌드가 해당 컨테이너에서 로드하면서 다른 노출된 모듈에 접근할 수 있다.

공유된 모듈은 오버라이딩 가능하고 중첩된 컨테이너에 오버라이드로 제공한다.
일반적으로 각 빌드에서 동일한 모듈(예, 동일한 라이브러리)을 가리킨다.

`packageName` 옵션을 사용하면 `requiredVersion`을 찾도록 패키지 이름을 설정할 수 있다.
기본적으로 모듈 요청에 자동으로 추론된다.

(자동 추론을 비활성화해야 하는 경우 `requiredVersion`을 `false`로 설정한다.)

## Concept goals

다음과 같은 목적들을 가진다.

- webpack이 지원하는 모든 모듈 유형을 노출하고 사용할 수 있어야 합니다.
- 청크 로드는 필요한 모든 것을 병렬 로드 해야 합니다(웹: 서버까지 한번의 라운드트립).
- 소비자에서 컨테이너까지 제어.
  - 오버라이딩 모듈은 단방향 작업입니다.
  - 형제 컨테이너는 서로의 모듈을 오버라이드 할 수 없습니다.
- 환경에 의존하지 않습니다.
  - 웹, Node.js, 등에서 사용 가능합니다.
- 공유의 상대 및 절대 요청
  - 사용하지 않더라도 항상 제공됩니다.
  - 상대 경로를 config.context에서 확인할 수 있습니다.
  - 기본적으로 requiredVersion을 사용하지 않습니다.
- 공유 모듈 요청
  - 사용할 때만 제공됩니다.
  - 빌드에서 사용된 모든 동일 모듈 요청과 일치합니다.
  - 일치하는 모든 모듈을 제공합니다.
  - 그래프의 이 위치에 있는 package.json에서 requiredVersion을 추출합니다.
  - 중첩된 node_module이 있는 경우 여러 다른 버전을 제공하고 사용할 수 있습니다.
- 공유된 후행에 / 가 있는 모듈 요청은 이 접두사의 모든 모듈 요청과 일치합니다.

## Use cases

### Separate builds per page

페이지별로 별도로 배포한다.

SPA의 각 페이지는 별도의 빌드 과정에서 컨테이너 빌드로부터 원격에서 접근할 수 있도록 노출된다.
또한 애플리케이션 쉘은 모든 페이지를 원격 모듈로 참조하는 별도의 빌드입니다.

애플리케이션 쉘은 페이지 빌드에서 중복을 방지하기 위해 일반적으로 사용되는 라이브러리를 공유 모듈로 정의한다.
(ex: lodash...)

### Components library as container

많은 애플리케이션은 각 컴포넌트가 노출된 컨테이너로 빌드 할 수 있는 공통 컴포넌트 라이브러리를 공유한다.

각 애플리케이션은 컴포넌트 라이브러리 컨테이너의 컴포넌트를 사용한다. 모든 애플리케이션을 다시 배포할 필요 없이 컴포넌트 라이브러리의 변경을 별도로 배포할 수 있다.

애플리케이션은 컴포넌트 라이브러리의 최신 버전을 자동으로 사용한다.
(의존성을 컴포넌트 컨테이너에서 관리)
